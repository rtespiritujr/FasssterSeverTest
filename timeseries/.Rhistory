}
if (t <= tail(equar.l, n = 1)) {
reallam = (lambdaValuesInput[min(which(t <= equar.l))])
} else {
reallam = 0
}
if (format(first_date + t,"%m") == "03") { #t starts at 1
deltaS = deltaSMarch
} else if (format(first_date + t,"%m") == "04") {
deltaS = deltaSApril
} else if (format(first_date + t,"%m") == "05") {
deltaS = deltaSMay
} else if (format(first_date + t,"%m") == "06"){
deltaS = deltaSJune
} else if (format(first_date + t,"%m") == "07"){
deltaS = deltaSJuly
} else {
deltaS = deltaSAugust
}
if(t >= setdate){
deltaS = setdelt
}
dS = A - (1-reallam)*(1-interventionEffect)*beta*S*(IA + IS)/(S+E+IA+IS+Q+R) - mu*S
dE = (1-reallam)*(1-interventionEffect)*beta*S*(IA + IS)/(S+E+IA+IS+Q+R) - (mu + 1/tau)*E
dIA = c*E/tau - (mu + omega + deltaA + theta)*IA
dIS = (1-c)*E/tau + omega*IA - (mu + epsT + deltaS)*IS # changed eps I to eps T
dQ = deltaA*IA + deltaS*IS - (mu + epsT + r)*Q
dC = deltaA*IA + deltaS*IS
dD = epsT*IA + epsT*C
dR = theta*IA + r*Q - mu*R
list(c(dS, dE, dIA, dIS, dQ, dC, dD, dR))
})
}
scen = which(summaries$area == psgcInput & summaries$FittedTo == fitParamToUse)
first_date = as.Date(as.character(summaries[scen, 'first_date']))
inputs = summaries[scen, ]
inputs = suppressWarnings(as.numeric(inputs))
names(inputs) = colnames(summaries)[1:ncol(summaries)]
N = inputs['pop']
A = N*0.020177/365
equar.l = as.numeric((lambdaDateInput - first_date + 1))
pars = parGen_estimateLambda2()
setdate = as.numeric(startHcDate - first_date) + 1
setdelt = HcLevel
intervStartDate = as.numeric(interventionStartDate - first_date) + 1
intervEndDate = as.numeric(interventionEndDate - first_date) + 1
istates = c(S = as.numeric(N),
E = as.numeric(inputs['E0']),
IA = as.numeric(inputs['IA0']),
IS = as.numeric(inputs['IS0']),
Q = as.numeric(inputs['C0']),
C = as.numeric(inputs['C0']),
D = 0,
R = 0)
projtime = seq(1, projectionDuration, by = 1)
check = ode(y=istates,time=projtime,func=Covid19Model,parms=pars)
check = as.data.frame(check[,2:ncol(check)])
dailyDeaths = c(0,diff(check$D))
dailyRecovered =  c(0,diff(check$R))
dailyCritical = check$Q*.06
dailySevere = check$Q*.14
dailyMild = check$Q*.80
cumulativeCritical = check$C*.06
cumulativeSevere = check$C*.14
cumulativeMild = check$C*.80
totalInfectious = check$IA + check$IS
datesSequence = data.frame(Date = seq(first_date,
first_date + (nrow(check)-1),
1,))
checkReturn = cbind(format(datesSequence, "%Y-%m-%d"), check, dailyDeaths, dailyRecovered,
dailyCritical, dailySevere, dailyMild,
cumulativeCritical, cumulativeSevere, cumulativeMild,
totalInfectious)
actualIncidenceCounts = getActiveCases(psgcInput)
maxDateIndex = which(as.character(checkReturn$Date) == maxDate)
maxCumulative = tail(actualIncidenceCounts$CumulativeSumAdmitted, n=1)
rangeOfCheck = checkReturn$C[(maxDateIndex-dateAdjustmentSearchSpace):(maxDateIndex+dateAdjustmentSearchSpace)]
dateMovement = which(abs(rangeOfCheck-maxCumulative) == min(abs(rangeOfCheck-maxCumulative))) - (dateAdjustmentSearchSpace+1)
maxCumulative
dateMovement
firstDate
psgcDetails = getPsgcDetails(psgcInput)
firstDate = as.Date(psgcDetails[which(psgcDetails$FittedTo == fitParamToUse), "first_date"])
View(checkReturn)
if(dateAdjustment){
maxDateIndex = which(as.character(checkReturn$Date) == maxDate)
#Movement to match latest data and projections
if (fitParamToUse == "Cumulative") {
maxCumulative = tail(actualIncidenceCounts$CumulativeSumAdmitted, n=1)
rangeOfCheck = checkReturn$C[(maxDateIndex-dateAdjustmentSearchSpace):(maxDateIndex+dateAdjustmentSearchSpace)]
dateMovement = which(abs(rangeOfCheck-maxCumulative) == min(abs(rangeOfCheck-maxCumulative))) - (dateAdjustmentSearchSpace+1)
} else {
maxActive = tail(actualIncidenceCounts$ActiveCases, n=1)
rangeOfCheck = checkReturn$Q[(maxDateIndex-dateAdjustmentSearchSpace):(maxDateIndex+dateAdjustmentSearchSpace)]
dateMovement = which(abs(rangeOfCheck-maxActive) == min(abs(rangeOfCheck-maxActive))) - (dateAdjustmentSearchSpace+1)
}
datesSequence = data.frame(Date = seq(first_date - dateMovement,
first_date + (nrow(check)-1) - dateMovement,
1,))
checkReturn = cbind(format(datesSequence, "%Y-%m-%d"),checkReturn[,c(2:(ncol(checkReturn)))])
} else {
dateMovement = 0
}
checkReturn = merge(x = checkReturn, y = actualIncidenceCounts, by = "Date", all.x = TRUE)
if (scaleLevel != 0) {
checkReturn = as.data.frame((checkReturn[,2:ncol(checkReturn)]/(inputs['pop']/inputs['popMultiplier']))*scaleLevel)
checkReturn = cbind(datesSequence,checkReturn)
}
View(checkReturn)
which(checkReturn$Date >= firstDate)
psgcDetails = getPsgcDetails(psgcInput)
checkReturn$Date = as.Date(checkReturn$Date)
checkReturn$Date
checkReturn$Date = as.Date(as.character(checkReturn$Date))
checkReturn
View(checkReturn)
psgcDetails = getPsgcDetails(psgcInput)
firstDate = as.Date(psgcDetails[which(psgcDetails$FittedTo == fitParamToUse), "first_date"])
which(checkReturn$Date >= firstDate)
projectionDuration = "200"
origProjectDuration = as.numeric(projectionDuration)
projectionDuration = as.numeric(projectionDuration) + dateAdjustmentSearchSpace + 1
projectionDuration
origProjectDuration
lastDate = firstDate + origProjectDuration - 1
lastDate
which(checkReturn$Date >= firstDate & checkReturn$Date <= lastDate)
checkReturn = checkReturn[which(checkReturn$Date >= firstDate & checkReturn$Date <= lastDate),]
checkReturn
View(checkReturn)
RunProjections(lambdaDateInput, lambdaValuesInput, psgcInput,
startHcDate, HcLevel, projectionDuration, scaleLevel, fitParamToUse,
interventionStartDate, interventionEndDate, interventionPercentage,
interventionCompliance, dateAdjustment)
RunProjections(lambdaDateInput, lambdaValuesInput, psgcInput,
startHcDate, HcLevel, projectionDuration, scaleLevel, fitParamToUse,
interventionStartDate, interventionEndDate, interventionPercentage,
interventionCompliance, dateAdjustment)
lambdaDateInput = "2020-04-01;2020-05-01;2020-06-01;2020-07-01;2020-08-01;2020-09-01"
lambdaValuesInput = "0.573225325970279;0.715457387212433;0.820393256916282;0.316807547787447;0.549936240227746;0.703688745658289"
psgcInput = "130000000"
startHcDate = "2020-09-01"
HcLevel = "0.17"
projectionDuration = "200"
scaleLevel = "0"
fitParamToUse = "Cumulative"
interventionStartDate = "2020-08-19"
interventionEndDate = "2025-01-01"
interventionPercentage = "0"
interventionCompliance = "0"
dateAdjustment = "TRUE"
RunProjections(lambdaDateInput, lambdaValuesInput, psgcInput,
startHcDate, HcLevel, projectionDuration, scaleLevel, fitParamToUse,
interventionStartDate, interventionEndDate, interventionPercentage,
interventionCompliance, dateAdjustment)
output = RunProjections(lambdaDateInput, lambdaValuesInput, psgcInput,
startHcDate, HcLevel, projectionDuration, scaleLevel, fitParamToUse,
interventionStartDate, interventionEndDate, interventionPercentage,
interventionCompliance, dateAdjustment)
oderes = output$OdeResult
View(oderes)
RunProjections = function(lambdaDateInput, lambdaValuesInput,
psgcInput, startHcDate, HcLevel, projectionDuration,
scaleLevel, fitParamToUse, interventionStartDate,
interventionEndDate, interventionPercentage,
interventionCompliance, dateAdjustment) {
dateAdjustmentSearchSpace = 50
lambdaDateInput = as.Date(strsplit(lambdaDateInput, ";")[[1]])
lambdaValuesInput = as.numeric(strsplit(lambdaValuesInput, ";")[[1]])
interventionStartDate = as.Date(interventionStartDate)
interventionEndDate = as.Date(interventionEndDate)
interventionPercentage = as.numeric(interventionPercentage)
interventionCompliance = as.numeric(interventionCompliance)
startHcDate = as.Date(startHcDate)
HcLevel = as.numeric(HcLevel)
origProjectDuration = as.numeric(projectionDuration)
projectionDuration = as.numeric(projectionDuration) + dateAdjustmentSearchSpace + 1
scaleLevel = as.numeric(scaleLevel)
dateAdjustment = as.logical(dateAdjustment)
parGen_estimateLambda2 = function(){ #tinanggal yung engineer = TRUE
parnames=c("tau", "beta", "c", "omega", "theta",  "r", "deltaA",
"deltaSMarch", "deltaSApril", "deltaSMay", "deltaSJune",
"deltaSJuly", "deltaSAugust", "epsT", "mu")
result = c(
computedParameters['tau'], inputs['beta'],# transmission
computedParameters['c'], computedParameters['omega'], # transitions
computedParameters['theta'], computedParameters['r'], # recoveries
computedParameters['deltaSMarch'], computedParameters['deltaSMarch'],
computedParameters['deltaSApril'], computedParameters['deltaSMay'],
computedParameters['deltaSJune'], computedParameters['deltaSJuly'],
computedParameters['deltaSAugust'],computedParameters['epsT'],
inputs['mu'] #computedParameters['mu'],# dying
)
names(result) = parnames
return(result)
}
Covid19Model = function(t, state, parameters){
with(as.list(c(state,parameters)),{
if (t >= intervStartDate & t <= intervEndDate) {
interventionEffect = (interventionPercentage * interventionCompliance)
} else {
interventionEffect = 0
}
if (t <= tail(equar.l, n = 1)) {
reallam = (lambdaValuesInput[min(which(t <= equar.l))])
} else {
reallam = 0
}
if (format(first_date + t,"%m") == "03") { #t starts at 1
deltaS = deltaSMarch
} else if (format(first_date + t,"%m") == "04") {
deltaS = deltaSApril
} else if (format(first_date + t,"%m") == "05") {
deltaS = deltaSMay
} else if (format(first_date + t,"%m") == "06"){
deltaS = deltaSJune
} else if (format(first_date + t,"%m") == "07"){
deltaS = deltaSJuly
} else {
deltaS = deltaSAugust
}
if(t >= setdate){
deltaS = setdelt
}
dS = A - (1-reallam)*(1-interventionEffect)*beta*S*(IA + IS)/(S+E+IA+IS+Q+R) - mu*S
dE = (1-reallam)*(1-interventionEffect)*beta*S*(IA + IS)/(S+E+IA+IS+Q+R) - (mu + 1/tau)*E
dIA = c*E/tau - (mu + omega + deltaA + theta)*IA
dIS = (1-c)*E/tau + omega*IA - (mu + epsT + deltaS)*IS # changed eps I to eps T
dQ = deltaA*IA + deltaS*IS - (mu + epsT + r)*Q
dC = deltaA*IA + deltaS*IS
dD = epsT*IA + epsT*C
dR = theta*IA + r*Q - mu*R
list(c(dS, dE, dIA, dIS, dQ, dC, dD, dR))
})
}
scen = which(summaries$area == psgcInput & summaries$FittedTo == fitParamToUse)
first_date = as.Date(as.character(summaries[scen, 'first_date']))
inputs = summaries[scen, ]
inputs = suppressWarnings(as.numeric(inputs))
names(inputs) = colnames(summaries)[1:ncol(summaries)]
N = inputs['pop']
A = N*0.020177/365
equar.l = as.numeric((lambdaDateInput - first_date + 1))
pars = parGen_estimateLambda2()
setdate = as.numeric(startHcDate - first_date) + 1
setdelt = HcLevel
intervStartDate = as.numeric(interventionStartDate - first_date) + 1
intervEndDate = as.numeric(interventionEndDate - first_date) + 1
istates = c(S = as.numeric(N),
E = as.numeric(inputs['E0']),
IA = as.numeric(inputs['IA0']),
IS = as.numeric(inputs['IS0']),
Q = as.numeric(inputs['C0']),
C = as.numeric(inputs['C0']),
D = 0,
R = 0)
projtime = seq(1, projectionDuration, by = 1)
check = ode(y=istates,time=projtime,func=Covid19Model,parms=pars)
check = as.data.frame(check[,2:ncol(check)])
dailyDeaths = c(0,diff(check$D))
dailyRecovered =  c(0,diff(check$R))
dailyCritical = check$Q*.06
dailySevere = check$Q*.14
dailyMild = check$Q*.80
cumulativeCritical = check$C*.06
cumulativeSevere = check$C*.14
cumulativeMild = check$C*.80
totalInfectious = check$IA + check$IS
datesSequence = data.frame(Date = seq(first_date,
first_date + (nrow(check)-1),
1,))
checkReturn = cbind(format(datesSequence, "%Y-%m-%d"), check, dailyDeaths, dailyRecovered,
dailyCritical, dailySevere, dailyMild,
cumulativeCritical, cumulativeSevere, cumulativeMild,
totalInfectious)
actualIncidenceCounts = getActiveCases(psgcInput)
if(dateAdjustment){
maxDateIndex = which(as.character(checkReturn$Date) == maxDate)
#Movement to match latest data and projections
if (fitParamToUse == "Cumulative") {
maxCumulative = tail(actualIncidenceCounts$CumulativeSumAdmitted, n=1)
rangeOfCheck = checkReturn$C[(maxDateIndex-dateAdjustmentSearchSpace):(maxDateIndex+dateAdjustmentSearchSpace)]
dateMovement = which(abs(rangeOfCheck-maxCumulative) == min(abs(rangeOfCheck-maxCumulative))) - (dateAdjustmentSearchSpace+1)
} else {
maxActive = tail(actualIncidenceCounts$ActiveCases, n=1)
rangeOfCheck = checkReturn$Q[(maxDateIndex-dateAdjustmentSearchSpace):(maxDateIndex+dateAdjustmentSearchSpace)]
dateMovement = which(abs(rangeOfCheck-maxActive) == min(abs(rangeOfCheck-maxActive))) - (dateAdjustmentSearchSpace+1)
}
datesSequence = data.frame(Date = seq(first_date - dateMovement,
first_date + (nrow(check)-1) - dateMovement,
1,))
checkReturn = cbind(format(datesSequence, "%Y-%m-%d"),checkReturn[,c(2:(ncol(checkReturn)))])
} else {
dateMovement = 0
}
checkReturn = merge(x = checkReturn, y = actualIncidenceCounts, by = "Date", all.x = TRUE)
if (scaleLevel != 0) {
checkReturn = as.data.frame((checkReturn[,2:ncol(checkReturn)]/(inputs['pop']/inputs['popMultiplier']))*scaleLevel)
checkReturn = cbind(datesSequence,checkReturn)
}
checkReturn$Date = as.Date(as.character(checkReturn$Date))
psgcDetails = getPsgcDetails(psgcInput)
firstDate = as.Date(psgcDetails[which(psgcDetails$FittedTo == fitParamToUse), "first_date"])
lastDate = firstDate + origProjectDuration - 1
checkReturn = checkReturn[which(checkReturn$Date >= firstDate & checkReturn$Date <= lastDate),]
########### OTHER DETAILS ###########
peakIndex = which(checkReturn$Q == max(checkReturn$Q))
peakDate = checkReturn[peakIndex,"Date"]
peakConfirmed = checkReturn[peakIndex,"Q"]
peakMortality = checkReturn[peakIndex, "dailyDeaths"]
peakSevere = peakConfirmed*.14
peakCritical = peakConfirmed*.06
epidemicEndIndex = suppressWarnings(min(which(
checkReturn$IA < 1 &
checkReturn$IS < 1 &
checkReturn$Q < 1
)))
epidemicEndDate = checkReturn[epidemicEndIndex,"Date"]
otherInfo = data.frame(peakDate = as.character(peakDate), epidemicEndDate = as.character(epidemicEndDate),
peakConfirmed = peakConfirmed, peakMortality = peakMortality,
peakSevere = peakSevere, peakCritical = peakCritical, dateAdjustment = dateMovement)
##############
returnValues = list(OdeResult = checkReturn, OtherDetails = otherInfo)
return(returnValues)
}
output = RunProjections(lambdaDateInput, lambdaValuesInput, psgcInput,
startHcDate, HcLevel, projectionDuration, scaleLevel, fitParamToUse,
interventionStartDate, interventionEndDate, interventionPercentage,
interventionCompliance, dateAdjustment)
oderes = output$OdeResult
View(oderes)
setwd("..")
r = plumber::plumb("timeseries/1_Setup.R")
r$run(port=8585,swagger = TRUE)
lambdaDateInput = "2020-03-31;2020-04-30;2020-05-31;2020-06-30;2020-07-31;2020-08-31;2020-09-30"
lambdaValuesInput = "0.779234386556404;0.659984710220912;0.830605089237221;0.306594421457239;0.55343093203224;0.715454157235411;0.715454157235411"
psgcInput = "130000000"
startHcDate = "2020-09-01"
HcLevel = "0.17"
projectionDuration = "213"
scaleLevel = "0"
fitParamToUse = "Active"
interventionStartDate = "2020-08-19"
interventionEndDate = "2025-01-01"
interventionPercentage = "0"
interventionCompliance = "0"
dateAdjustment = "TRUE"
output = RunProjections(lambdaDateInput, lambdaValuesInput, psgcInput,
startHcDate, HcLevel, projectionDuration, scaleLevel, fitParamToUse,
interventionStartDate, interventionEndDate, interventionPercentage,
interventionCompliance, dateAdjustment)
oderes = output$OdeResult
View(oderes)
View(oderes)
dateAdjustment = "FALSE"
output = RunProjections(lambdaDateInput, lambdaValuesInput, psgcInput,
startHcDate, HcLevel, projectionDuration, scaleLevel, fitParamToUse,
interventionStartDate, interventionEndDate, interventionPercentage,
interventionCompliance, dateAdjustment)
oderes = output$OdeResult
output = RunProjections(lambdaDateInput, lambdaValuesInput, psgcInput,
startHcDate, HcLevel, projectionDuration, scaleLevel, fitParamToUse,
interventionStartDate, interventionEndDate, interventionPercentage,
interventionCompliance, dateAdjustment)
oderes = output$OdeResult
dateAdjustment = "TRUE"
dateAdjustmentSearchSpace = 50
lambdaDateInput = as.Date(strsplit(lambdaDateInput, ";")[[1]])
lambdaValuesInput = as.numeric(strsplit(lambdaValuesInput, ";")[[1]])
interventionStartDate = as.Date(interventionStartDate)
interventionEndDate = as.Date(interventionEndDate)
interventionPercentage = as.numeric(interventionPercentage)
interventionCompliance = as.numeric(interventionCompliance)
startHcDate = as.Date(startHcDate)
HcLevel = as.numeric(HcLevel)
origProjectDuration = as.numeric(projectionDuration)
projectionDuration = as.numeric(projectionDuration) + dateAdjustmentSearchSpace + 1
scaleLevel = as.numeric(scaleLevel)
dateAdjustment = as.logical(dateAdjustment)
parGen_estimateLambda2 = function(){ #tinanggal yung engineer = TRUE
parnames=c("tau", "beta", "c", "omega", "theta",  "r", "deltaA",
"deltaSMarch", "deltaSApril", "deltaSMay", "deltaSJune",
"deltaSJuly", "deltaSAugust", "epsT", "mu")
result = c(
computedParameters['tau'], inputs['beta'],# transmission
computedParameters['c'], computedParameters['omega'], # transitions
computedParameters['theta'], computedParameters['r'], # recoveries
computedParameters['deltaSMarch'], computedParameters['deltaSMarch'],
computedParameters['deltaSApril'], computedParameters['deltaSMay'],
computedParameters['deltaSJune'], computedParameters['deltaSJuly'],
computedParameters['deltaSAugust'],computedParameters['epsT'],
inputs['mu'] #computedParameters['mu'],# dying
)
names(result) = parnames
return(result)
}
Covid19Model = function(t, state, parameters){
with(as.list(c(state,parameters)),{
if (t >= intervStartDate & t <= intervEndDate) {
interventionEffect = (interventionPercentage * interventionCompliance)
} else {
interventionEffect = 0
}
if (t <= tail(equar.l, n = 1)) {
reallam = (lambdaValuesInput[min(which(t <= equar.l))])
} else {
reallam = 0
}
if (format(first_date + t,"%m") == "03") { #t starts at 1
deltaS = deltaSMarch
} else if (format(first_date + t,"%m") == "04") {
deltaS = deltaSApril
} else if (format(first_date + t,"%m") == "05") {
deltaS = deltaSMay
} else if (format(first_date + t,"%m") == "06"){
deltaS = deltaSJune
} else if (format(first_date + t,"%m") == "07"){
deltaS = deltaSJuly
} else {
deltaS = deltaSAugust
}
if(t >= setdate){
deltaS = setdelt
}
dS = A - (1-reallam)*(1-interventionEffect)*beta*S*(IA + IS)/(S+E+IA+IS+Q+R) - mu*S
dE = (1-reallam)*(1-interventionEffect)*beta*S*(IA + IS)/(S+E+IA+IS+Q+R) - (mu + 1/tau)*E
dIA = c*E/tau - (mu + omega + deltaA + theta)*IA
dIS = (1-c)*E/tau + omega*IA - (mu + epsT + deltaS)*IS # changed eps I to eps T
dQ = deltaA*IA + deltaS*IS - (mu + epsT + r)*Q
dC = deltaA*IA + deltaS*IS
dD = epsT*IA + epsT*C
dR = theta*IA + r*Q - mu*R
list(c(dS, dE, dIA, dIS, dQ, dC, dD, dR))
})
}
scen = which(summaries$area == psgcInput & summaries$FittedTo == fitParamToUse)
first_date = as.Date(as.character(summaries[scen, 'first_date']))
inputs = summaries[scen, ]
inputs = suppressWarnings(as.numeric(inputs))
names(inputs) = colnames(summaries)[1:ncol(summaries)]
N = inputs['pop']
A = N*0.020177/365
equar.l = as.numeric((lambdaDateInput - first_date + 1))
pars = parGen_estimateLambda2()
setdate = as.numeric(startHcDate - first_date) + 1
setdelt = HcLevel
intervStartDate = as.numeric(interventionStartDate - first_date) + 1
intervEndDate = as.numeric(interventionEndDate - first_date) + 1
istates = c(S = as.numeric(N),
E = as.numeric(inputs['E0']),
IA = as.numeric(inputs['IA0']),
IS = as.numeric(inputs['IS0']),
Q = as.numeric(inputs['C0']),
C = as.numeric(inputs['C0']),
D = 0,
R = 0)
projtime = seq(1, projectionDuration, by = 1)
check = ode(y=istates,time=projtime,func=Covid19Model,parms=pars)
check = as.data.frame(check[,2:ncol(check)])
dailyDeaths = c(0,diff(check$D))
dailyRecovered =  c(0,diff(check$R))
dailyCritical = check$Q*.06
dailySevere = check$Q*.14
dailyMild = check$Q*.80
cumulativeCritical = check$C*.06
cumulativeSevere = check$C*.14
cumulativeMild = check$C*.80
totalInfectious = check$IA + check$IS
datesSequence = data.frame(Date = seq(first_date,
first_date + (nrow(check)-1),
1,))
checkReturn = cbind(format(datesSequence, "%Y-%m-%d"), check, dailyDeaths, dailyRecovered,
dailyCritical, dailySevere, dailyMild,
cumulativeCritical, cumulativeSevere, cumulativeMild,
totalInfectious)
actualIncidenceCounts = getActiveCases(psgcInput)
dateAdjustment
maxDateIndex = which(as.character(checkReturn$Date) == maxDate)
maxDateIndex
which(as.character(checkReturn$Date) == maxDate)
as.character(checkReturn$Date)
maxDate
maxDateIndex
#Movement to match latest data and projections
if (fitParamToUse == "Cumulative") {
maxCumulative = tail(actualIncidenceCounts$CumulativeSumAdmitted, n=1)
rangeOfCheck = checkReturn$C[(maxDateIndex-dateAdjustmentSearchSpace):(maxDateIndex+dateAdjustmentSearchSpace)]
dateMovement = which(abs(rangeOfCheck-maxCumulative) == min(abs(rangeOfCheck-maxCumulative))) - (dateAdjustmentSearchSpace+1)
} else {
maxActive = tail(actualIncidenceCounts$ActiveCases, n=1)
rangeOfCheck = checkReturn$Q[(maxDateIndex-dateAdjustmentSearchSpace):(maxDateIndex+dateAdjustmentSearchSpace)]
dateMovement = which(abs(rangeOfCheck-maxActive) == min(abs(rangeOfCheck-maxActive))) - (dateAdjustmentSearchSpace+1)
}
dateMovement
fitParamToUse
maxActive = tail(actualIncidenceCounts$ActiveCases, n=1)
maxActive
maxActive
rangeOfCheck
maxActive
rangeOfCheck
abs(rangeOfCheck-maxActive)
min(abs(rangeOfCheck-maxActive)
)
dateAdjustmentSearchSpace
maxDateIndex
dateAdjustmentSearchSpace
dateAdjustmentSearchSpace
maxDateIndex-dateAdjustmentSearchSpace
maxDateIndex+dateAdjustmentSearchSpace
r = plumber::plumb("timeseries/1_Setup.R")
r$run(port=8585,swagger = TRUE)
